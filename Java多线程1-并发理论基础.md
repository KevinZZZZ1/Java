# 并发理论基础

[TOC]

## 可见性、原子性和有序性

- 可见性：多核环境下，缓存造成的变量可见性被破坏；
- 原子性：由于高级语言的一条语句，会分解成多个CPU指令，多线程时分复用的操作系统中，在任意指令结束都可能会发生线程切换，这样导致高级语言语句的原子性无法保证；
- 有序性：由于编译器对代码的优化会导致程序运行的顺序和代码书写顺序不一样，这就导致程序的有序性无法保证，在一些场合下会导致并发程序出现问题；

硬件设备的不断迭代，使得CPU的处理速度越来越快，但是这会导致一个问题：**CPU、内存、I/O设备的速度不匹配的问题**，CPU与内存的处理速度差异相对来说还行，内存和I/O设备之间的速度差异则是巨大的，**所以I/O操作成为了大部分系统的瓶颈**，为了解决这一问题，有以下三种解决方案：

- CPU增加了缓存，均衡CPU和内存间的速度差异；
- 操作系统增加了线程、进程，以分时复用CPU，均衡内存和I/O设备间的速度差异；
- 编译程序对代码指令执行次序进行优化，能更充分的使用缓存；

但是，并发编程问题多的原因正是来自于上面的成果；

### 缓存导致的可见性问题

在单核CPU时代，所有线程都是运行在同一个CPU上，使用同一缓存，即使线程A对缓存中的变量V进行了修改，切换到线程B之后，线程A对变量V的修改，线程B是可知的，这叫做**可见性**；

**在多核时代，缓存就会带来可见性问题**，即如果线程A在CPU1上执行，并在其缓存中修改了变量V的值，而线程B在CPU2上执行，其缓存中并不能知道线程A对于变量V的修改，所以变量的可见性就无法保证；



### 线程切换带来的原子性问题

由于I/O速度太慢，如果让进程一直阻塞等待I/O响应，导致CPU利用率低，会浪费CPU资源，所以**多进程分时复用操作系统的出现完美的解决了CPU利用率低的问题**；

多进程分时复用操作系统运行某个进程执行一个时间片的时间，在下一个时间片操作系统会重新选择一个进程来执行，这就叫做任务切换；早期操作系统使用进程作为任务切换的单位，**但是进程不共享内存空间，切换起来很麻烦，而一个进程创建的所有线程是共享内存空间的，切换起来成本很低，所以现在使用线程进行任务调度**；

**线程切换（任务切换）是导致并发编程结果不确定的原因之一，由于高级语言的一条语句是由多条CPU指令组成的**，线程切换一般发生在时间片结束时，此时一条语句的CPU指令可能还没执行完，导致高级语言语句的原子性无法保证；（CPU指令的原子性可以保证）

比如这个执行count++的例子：

![avatar](F:\找工作\Java基础\Java\images\并发编程原子性.png)

**我们潜意识会任务count++是一个不可分割的整体，其实并不是这样的，这也是并发程序出现bug的原因之一**；

### 编译优化带来的有序性问题

有序性是指，程序按照代码的书写的先后顺序进行执行，**但是在编译的时候编译器可能会进行优化，导致程序执行的时候并不是按照代码的书写顺序执行**，这样的优化可能就会导致并发编程出现bug；

一个经典的例子就是，利用双重检查创建单例对象：

```java
public class Singleton{
    private static Singleton instance;
    public static Singleton getInstance(){
        if(instance == null){
            synchronized(Singleton.class){
                if(instance == null)
                    instance = new Singleton();
            }
            
        }
        return instance;
    }
}
```

表面上看假设有两个线程 A、B 同时调用 getInstance()方法，他们会同时发现 instance == null ，于是同时instance == null ，于是同时对 Singleton.class 加锁，此时 JVM 保证只有一个线程能够加锁成功（假设是线程 A），另外一个线程则会处于等待状态（假设是线程 B）；线程 A 会创建一个 Singleton 实例，之后释放锁，锁释放后，线程 B 被唤醒，线程 B 再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程 B 检查 instance == null时会发现，已经创建过 Singleton 实例了，所以线程 B 不会再创建一个 Singleton 实例。

目前为止，感觉上面程序并没有问题，**但是在考虑过有序性问题之后就会发现上面代码的问题**：

我们以为的new操作是：

- 分配一块内存M；
- 在内存M上初始化Singleton对象；
- 把M的地址赋值给instance变量；

其实，由于编译器优化代码导致有序性无法保证，实际的执行是这样的：

- 分配一块内存M；
- 将M的地址赋值给instance变量；
- 在内存M上初始化Singleton对象；

这就会导致如下图的问题：

![avatar](F:\找工作\Java基础\Java\images\并发编程有序性.png)

如何修改这个bug呢？由于问题出在无法保证有序性，**所以需要一种手段来保证原子性，即使用volatile关键字来修饰instance变量，从而保证有序性**

```java
public class Singleton{
    private volatile static Singleton instance;
    public static Singleton getInstance(){
        if(instance == null){
            synchronized(Singleton.class){
                if(instance == null)
                    instance = new Singleton();
            }
            
        }
        return instance;
    }
}
```











## Java内存模型





## 互斥锁







## 死锁





## 等待-通知机制





## 安全性、活跃性以及性能问题





## 管程





## Java线程





## 面向对象和并发编程



